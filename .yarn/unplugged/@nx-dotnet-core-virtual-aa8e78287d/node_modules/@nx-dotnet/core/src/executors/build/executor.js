"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const devkit_1 = require("@nx/devkit");
const fs_1 = require("fs");
const path_1 = require("path");
const dotnet_1 = require("@nx-dotnet/dotnet");
const utils_1 = require("@nx-dotnet/utils");
function runExecutor(options, context, dotnetClient = new dotnet_1.DotNetClient((0, dotnet_1.dotnetFactory)())) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const nxProjectConfiguration = (0, utils_1.getExecutedProjectConfiguration)(context);
        removeOldArtifacts(context, nxProjectConfiguration);
        dotnetClient.cwd = (0, path_1.resolve)(devkit_1.workspaceRoot, nxProjectConfiguration.root);
        dotnetClient.printSdkVersion();
        const projectFilePath = (0, path_1.resolve)(devkit_1.workspaceRoot, yield (0, utils_1.getProjectFileForNxProject)(nxProjectConfiguration));
        const { extraParameters } = options, flags = tslib_1.__rest(options, ["extraParameters"]);
        options.output = options.output
            ? (0, path_1.resolve)(devkit_1.workspaceRoot, options.output)
            : undefined;
        dotnetClient.build(projectFilePath, flags, extraParameters);
        return {
            success: true,
        };
    });
}
exports.default = runExecutor;
function removeOldArtifacts(context, projectConfiguration) {
    var _a, _b, _c, _d, _e;
    const outputs = (_b = (_a = context.target) === null || _a === void 0 ? void 0 : _a.outputs) === null || _b === void 0 ? void 0 : _b.map((output) => (0, path_1.join)(context.root, (0, utils_1.inlineNxTokens)(output, projectConfiguration)));
    if (!outputs &&
        Object.values((_d = (_c = context.nxJsonConfiguration) === null || _c === void 0 ? void 0 : _c.tasksRunnerOptions) !== null && _d !== void 0 ? _d : {}).some((runnerOptions) => {
            var _a, _b;
            return (_b = (_a = runnerOptions.options) === null || _a === void 0 ? void 0 : _a.cacheableOperations) === null || _b === void 0 ? void 0 : _b.includes(context.targetName);
        })) {
        throw new Error(`[nx-dotnet] ${context.projectGraph}:${context.targetName} is cacheable, but has no outputs listed. 

This will result in cache hits not retrieving build artifacts, only terminal outputs.

See: https://nx.dev/reference/project-configuration#outputs`);
    }
    for (const output of outputs || []) {
        if (
        // No reason to clear build intermediates, just makes the resulting build command slower.
        !output.includes('intermediates') &&
            !output.endsWith('obj') &&
            (
            // Prevent exceptions from trying to rmdirSync(globPattern)
            (_e = getStatsOrNull(output)) === null || _e === void 0 ? void 0 : _e.isDirectory())) {
            (0, fs_1.rmSync)(output, { recursive: true });
        }
    }
}
function getStatsOrNull(f) {
    try {
        return (0, fs_1.statSync)(f);
    }
    catch (_a) {
        return null;
    }
}
//# sourceMappingURL=executor.js.map