"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.loadModuleBoundaries = exports.checkModuleBoundariesForProject = void 0;
const tslib_1 = require("tslib");
const devkit_1 = require("@nx/devkit");
const path_1 = require("path");
const utils_1 = require("@nx-dotnet/utils");
function checkModuleBoundariesForProject(project, projects) {
    var _a;
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const projectRoot = projects[project].root;
        const tags = (_a = projects[project].tags) !== null && _a !== void 0 ? _a : [];
        if (!tags.length) {
            return [];
        }
        const constraints = yield getProjectConstraints(projectRoot, tags);
        if (!constraints.length) {
            return [];
        }
        const violations = [];
        (0, utils_1.getDependantProjectsForNxProject)(project, { version: 2, projects }, (configuration, name, implicit) => {
            var _a;
            if (implicit)
                return;
            const dependencyTags = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.tags) !== null && _a !== void 0 ? _a : [];
            for (const constraint of constraints) {
                if (hasConstraintViolation(constraint, dependencyTags)) {
                    violations.push(`${project} cannot depend on ${name}. Project tag ${JSON.stringify(constraint)} is not satisfied.`);
                }
            }
        });
        return violations;
    });
}
exports.checkModuleBoundariesForProject = checkModuleBoundariesForProject;
function getProjectConstraints(root, tags) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const configuredConstraints = yield loadModuleBoundaries(root);
        return configuredConstraints.filter((x) => {
            var _a, _b, _c;
            return ((x.sourceTag && hasMatch(tags, x.sourceTag)) ||
                ((_a = x.allSourceTags) === null || _a === void 0 ? void 0 : _a.every((tag) => hasMatch(tags, tag)))) &&
                (!((_b = x.onlyDependOnLibsWithTags) === null || _b === void 0 ? void 0 : _b.includes('*')) ||
                    ((_c = x.notDependOnLibsWithTags) === null || _c === void 0 ? void 0 : _c.length));
        });
    });
}
function hasConstraintViolation(constraint, dependencyTags) {
    return (!dependencyTags.some((x) => { var _a; return hasMatch((_a = constraint.onlyDependOnLibsWithTags) !== null && _a !== void 0 ? _a : [], x); }) ||
        dependencyTags.some((x) => { var _a; return hasMatch((_a = constraint.notDependOnLibsWithTags) !== null && _a !== void 0 ? _a : [], x); }));
}
/**
 * Loads module boundaries from eslintrc or .nx-dotnet.rc.json
 * @param root Which file should be used when pulling from eslint
 * @returns List of module boundaries
 */
function loadModuleBoundaries(root, host) {
    var _a;
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const configured = (0, utils_1.readConfig)(host).moduleBoundaries;
        console.log('CONFIGURED', configured);
        if (!configured) {
            try {
                // eslint-disable-next-line @typescript-eslint/no-var-requires
                const { ESLint } = require('eslint');
                const result = yield new ESLint()
                    .calculateConfigForFile(`${root}/non-existant.ts`)
                    .catch(() => Promise.resolve({
                    rules: { '@nx/enforce-module-boundaries': [] },
                }));
                const [, moduleBoundaryConfig] = result.rules['@nx/enforce-module-boundaries'] ||
                    result.rules['@nrwl/nx/enforce-module-boundaries'] ||
                    [];
                return (_a = moduleBoundaryConfig === null || moduleBoundaryConfig === void 0 ? void 0 : moduleBoundaryConfig.depConstraints) !== null && _a !== void 0 ? _a : [];
            }
            catch (_b) {
                return [];
            }
        }
        else {
            return configured;
        }
    });
}
exports.loadModuleBoundaries = loadModuleBoundaries;
function findProjectGivenRoot(root, projects) {
    var _a;
    // Note that this returns the first matching project and would succeed for multiple (cs|fs...)proj under an nx project path,
    // but getProjectFileForNxProject explicitly throws if it's not exactly one.
    const normalizedRoot = root.replace(/^["'](.+(?=["']$))["']$/, '$1');
    const [projectName] = (_a = Object.entries(projects).find(([, projectConfig]) => {
        const relativePath = (0, path_1.relative)(projectConfig.root, normalizedRoot);
        return (relativePath === null || relativePath === void 0 ? void 0 : relativePath.startsWith('..')) === false;
    })) !== null && _a !== void 0 ? _a : [];
    if (projectName) {
        return projectName;
    }
    else {
        console.error(`Failed to find nx workspace project associated with dotnet project directory: ${root}`);
        process.exit(1);
    }
}
const regexMap = new Map();
function hasMatch(input, pattern) {
    if (pattern === '*')
        return true;
    // if the pattern is a regex, check if any of the input strings match the regex
    if (pattern.startsWith('/') && pattern.endsWith('/')) {
        let regex = regexMap.get(pattern);
        if (!regex) {
            regex = new RegExp(pattern.substring(1, pattern.length - 1));
            regexMap.set(pattern, regex);
        }
        return input.some((t) => regex === null || regex === void 0 ? void 0 : regex.test(t));
    }
    // if the pattern is a glob, check if any of the input strings match the glob prefix
    if (pattern.includes('*')) {
        const regex = mapGlobToRegExp(pattern);
        return input.some((t) => regex.test(t));
    }
    return input.indexOf(pattern) > -1;
}
/**
 * Maps import with wildcards to regex pattern
 * @param importDefinition
 * @returns
 */
function mapGlobToRegExp(importDefinition) {
    // we replace all instances of `*`, `**..*` and `.*` with `.*`
    const mappedWildcards = importDefinition.split(/(?:\.\*)|\*+/).join('.*');
    return new RegExp(`^${new RegExp(mappedWildcards).source}$`);
}
function main() {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const parser = yield Promise.resolve().then(() => require('yargs-parser'));
        const { project, projectRoot } = parser(process.argv.slice(2), {
            alias: {
                project: 'p',
            },
            string: ['project', 'projectRoot'],
        });
        const graph = yield (0, devkit_1.createProjectGraphAsync)();
        const { projects } = (0, devkit_1.readProjectsConfigurationFromProjectGraph)(graph);
        // Find the associated nx project for the msbuild project directory.
        const nxProject = project !== null && project !== void 0 ? project : findProjectGivenRoot(projectRoot, projects);
        console.log(`Checking module boundaries for ${nxProject}`);
        const violations = yield checkModuleBoundariesForProject(nxProject, projects);
        if (violations.length) {
            violations.forEach((error) => {
                console.error(error);
            });
            process.exit(1);
        }
        process.exit(0);
    });
}
if (require.main === module) {
    process.chdir(devkit_1.workspaceRoot);
    main();
}
//# sourceMappingURL=check-module-boundaries.js.map