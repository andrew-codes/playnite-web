"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parsePropertyDefintion = exports.generatePropertiesFromSchema = void 0;
const devkit_1 = require("@nx/devkit");
const swagger_ts_type_map_1 = require("../constants/swagger-ts-type-map");
const string_utils_1 = require("./string-utils");
function generatePropertiesFromSchema(schemaProperties) {
    const properties = Object.entries(schemaProperties || {});
    const typeScriptProperties = [];
    for (const [propertyName, propertyDefinition] of properties) {
        typeScriptProperties.push(Object.assign({ name: propertyName }, parsePropertyDefintion(propertyDefinition)));
    }
    return typeScriptProperties;
}
exports.generatePropertiesFromSchema = generatePropertiesFromSchema;
function parsePropertyDefintion(propertyDefinition) {
    if ('$ref' in propertyDefinition) {
        if (!propertyDefinition['$ref']) {
            devkit_1.logger.warn(`Invalid reference in definition`);
            throw new Error('$ref should be a string');
        }
        const reference = (0, string_utils_1.getTypeNameFromReference)(propertyDefinition['$ref']);
        return {
            type: reference,
            nullable: 'nullable' in propertyDefinition
                ? !!propertyDefinition.nullable
                : false,
        };
    }
    else if (propertyDefinition.type &&
        typeof propertyDefinition.type === 'string' &&
        propertyDefinition.type in swagger_ts_type_map_1.builtInTypeMap) {
        return {
            type: swagger_ts_type_map_1.builtInTypeMap[propertyDefinition.type],
            nullable: 'nullable' in propertyDefinition
                ? !!propertyDefinition.nullable
                : false,
        };
    }
    else if (propertyDefinition.type === 'object') {
        return {
            type: 'object',
            properties: generatePropertiesFromSchema(propertyDefinition.properties),
            nullable: 'nullable' in propertyDefinition ? !!propertyDefinition.nullable : true,
        };
    }
    else if (propertyDefinition.type === 'array' &&
        'items' in propertyDefinition) {
        const items = propertyDefinition.items;
        const property = parsePropertyDefintion(items);
        if ((property === null || property === void 0 ? void 0 : property.type) !== 'object') {
            return {
                type: `${property === null || property === void 0 ? void 0 : property.type}[]`,
                nullable: 'nullable' in propertyDefinition
                    ? !!propertyDefinition.nullable
                    : true,
            };
        }
    }
    devkit_1.logger.warn('Unexpected type: ' + propertyDefinition.type);
    throw new Error('Missing type mapping');
}
exports.parsePropertyDefintion = parsePropertyDefintion;
//# sourceMappingURL=parse-schema-object.js.map