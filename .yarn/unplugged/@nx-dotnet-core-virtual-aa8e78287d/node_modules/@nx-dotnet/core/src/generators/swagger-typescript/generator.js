"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const devkit_1 = require("@nx/devkit");
const path = require("path");
const build_interfaces_1 = require("./build-typescript-representation/build-interfaces");
const swagger_ts_type_map_1 = require("./constants/swagger-ts-type-map");
const normalize_options_1 = require("./utils/normalize-options");
function generateInterfaceFiles(tree, interfaces, options) {
    var _a, _b;
    const outputDirectory = (0, devkit_1.joinPathFragments)(options.outputDirectory, 'interfaces');
    for (const tsInterface of interfaces) {
        const necessaryImports = (_b = (tsInterface.type === 'interface'
            ? (_a = tsInterface.properties) === null || _a === void 0 ? void 0 : _a.map((prop) => prop.type.replace(/\[\]/g, ''))
            : tsInterface.type === 'array'
                ? [tsInterface.elements]
                : [])) === null || _b === void 0 ? void 0 : _b.reduce((necessary, next) => {
            if (next !== 'object' &&
                next !== tsInterface.name &&
                !swagger_ts_type_map_1.builtInTypes.has(next) &&
                !necessary.has(next)) {
                necessary.set(next, (0, devkit_1.names)(next));
            }
            return necessary;
        }, new Map());
        const templateOptions = Object.assign(Object.assign({}, options), { template: '', tmpl: '', interfaceFileName: (0, devkit_1.names)(tsInterface.name).fileName, interfaceClassName: (0, devkit_1.names)(tsInterface.name).className, tsInterface,
            necessaryImports });
        (0, devkit_1.generateFiles)(tree, path.join(__dirname, 'templates', 'interface'), outputDirectory, templateOptions);
    }
}
function generateIndex(tree, options) {
    const sourceFiles = [];
    const sourceDirectories = ['interfaces'];
    for (const directory of sourceDirectories) {
        const path = (0, devkit_1.joinPathFragments)(options.outputDirectory, directory);
        sourceFiles.push(...tree
            .children(path)
            .filter((x) => x.endsWith('.ts'))
            .map((x) => (0, devkit_1.joinPathFragments)(directory, x).replace(/\.ts$/, '')));
    }
    (0, devkit_1.generateFiles)(tree, path.join(__dirname, 'templates', 'index'), options.outputDirectory, {
        tmpl: '',
        sourceFiles,
    });
}
function default_1(tree, schema) {
    var _a;
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const options = (0, normalize_options_1.normalizeOptions)(tree, schema);
        const document = (0, devkit_1.readJson)(tree, options.openapiJsonPath);
        const interfaces = [];
        if ('definitions' in document && document.definitions) {
            interfaces.push(...(0, build_interfaces_1.generateInterfacesFromDefinitions)(document.definitions));
        }
        if ('components' in document && ((_a = document.components) === null || _a === void 0 ? void 0 : _a.schemas)) {
            interfaces.push(...(0, build_interfaces_1.generateInterfacesFromDefinitions)(document.components.schemas));
        }
        generateInterfaceFiles(tree, interfaces, options);
        generateIndex(tree, options);
        yield (0, devkit_1.formatFiles)(tree);
    });
}
exports.default = default_1;
//# sourceMappingURL=generator.js.map