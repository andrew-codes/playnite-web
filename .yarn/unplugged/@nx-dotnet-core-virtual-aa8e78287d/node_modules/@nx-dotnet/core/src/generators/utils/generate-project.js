"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.addPrebuildMsbuildTask = exports.GenerateProject = exports.normalizeOptions = void 0;
const tslib_1 = require("tslib");
const devkit_1 = require("@nx/devkit");
//  Files generated via `dotnet` are not available in the virtual fs
const path_1 = require("path");
const xmldoc_1 = require("xmldoc");
const utils_1 = require("@nx-dotnet/utils");
const models_1 = require("../../models");
const add_swagger_target_1 = require("../add-swagger-target/add-swagger-target");
const generator_1 = require("../init/generator");
const add_to_sln_1 = require("./add-to-sln");
const generate_test_project_1 = require("./generate-test-project");
const prompt_for_template_1 = require("./prompt-for-template");
const get_scope_1 = require("./get-scope");
function normalizeOptions(host, options, client, projectType) {
    var _a, _b, _c;
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const name = getNameFromSchema(options);
        const className = (0, devkit_1.names)(options.name).className;
        const projectDirectory = options.directory
            ? `${(0, devkit_1.names)(options.directory).fileName}/${name}`
            : name;
        const projectName = getProjectNameFromSchema(options, projectDirectory);
        const projectRoot = getProjectRootFromSchema(host, options, projectDirectory, projectType);
        const parsedTags = getProjectTagsFromSchema(options);
        const template = yield getTemplate(options, client);
        const namespaceName = getNamespaceFromSchema(host, options, projectDirectory);
        const nxProjectName = (0, devkit_1.names)(options.name).fileName;
        const __unparsed__ = (_a = options.__unparsed__) !== null && _a !== void 0 ? _a : [];
        const args = (_b = options.args) !== null && _b !== void 0 ? _b : [];
        return Object.assign(Object.assign({}, options), { name,
            className,
            projectName,
            projectRoot,
            projectDirectory,
            parsedTags, projectLanguage: options.language, projectTemplate: template, namespaceName,
            nxProjectName,
            args,
            __unparsed__, projectType: (_c = projectType !== null && projectType !== void 0 ? projectType : options.projectType) !== null && _c !== void 0 ? _c : 'library' });
    });
}
exports.normalizeOptions = normalizeOptions;
function getNameFromSchema(options) {
    return options.pathScheme === 'nx'
        ? (0, devkit_1.names)(options.name).fileName
        : options.name;
}
function getNamespaceFromSchema(host, options, projectDirectory) {
    const scope = (0, get_scope_1.getWorkspaceScope)(host);
    const namespaceParts = projectDirectory
        // not sure why eslint complains here, testing in devtools shows different results without the escape character.
        // eslint-disable-next-line no-useless-escape
        .split(/[\/\\]/gm) // Without the unnecessary parentheses, the separator is excluded from the result array.
        .map((part) => (0, devkit_1.names)(part).className);
    if (scope) {
        namespaceParts.unshift((0, devkit_1.names)(scope).className);
    }
    return namespaceParts.join('.');
}
function getTemplate(options, client) {
    var _a;
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        let template = (_a = options.template) !== null && _a !== void 0 ? _a : '';
        if (client) {
            template = yield (0, prompt_for_template_1.promptForTemplate)(client, options.template, options.language);
        }
        return template;
    });
}
function getProjectTagsFromSchema(options) {
    return options.tags ? options.tags.split(',').map((s) => s.trim()) : [];
}
function getProjectRootFromSchema(host, options, projectDirectory, projectType) {
    const workspaceLayoutRoot = (projectType || options.projectType) === 'application'
        ? (0, devkit_1.getWorkspaceLayout)(host).appsDir
        : (0, devkit_1.getWorkspaceLayout)(host).libsDir;
    return workspaceLayoutRoot
        ? (0, devkit_1.joinPathFragments)(workspaceLayoutRoot, projectDirectory)
        : projectDirectory;
}
function getProjectNameFromSchema(options, projectDirectory) {
    if (options.pathScheme === 'dotnet') {
        return options.directory
            ? `${(0, devkit_1.names)(options.directory).className}.${options.name}`
            : options.name;
    }
    return projectDirectory.replace(/\//g, '-');
}
function GenerateProject(host, options, dotnetClient, projectType) {
    var _a;
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const tasks = [
            yield (0, generator_1.initGenerator)(host, null, dotnetClient),
        ];
        options.testTemplate = (_a = options.testTemplate) !== null && _a !== void 0 ? _a : 'none';
        const normalizedOptions = yield normalizeOptions(host, options, dotnetClient, projectType);
        const projectConfiguration = {
            root: normalizedOptions.projectRoot,
            projectType: projectType,
            sourceRoot: `${normalizedOptions.projectRoot}`,
            targets: Object.assign(Object.assign({ build: (0, models_1.GetBuildExecutorConfiguration)(normalizedOptions.projectRoot) }, (projectType === 'application'
                ? { serve: (0, models_1.GetServeExecutorConfig)() }
                : {})), { lint: (0, models_1.GetLintExecutorConfiguration)() }),
            tags: normalizedOptions.parsedTags,
        };
        (0, devkit_1.addProjectConfiguration)(host, normalizedOptions.projectName, projectConfiguration);
        const newParams = {
            language: normalizedOptions.language,
            name: normalizedOptions.namespaceName,
            output: normalizedOptions.projectRoot,
        };
        const additionalArguments = normalizedOptions.args.concat(normalizedOptions.__unparsed__);
        if ((0, utils_1.isDryRun)()) {
            newParams['dryRun'] = true;
        }
        dotnetClient.new(normalizedOptions.projectTemplate, newParams, additionalArguments);
        if (!(0, utils_1.isDryRun)()) {
            (0, add_to_sln_1.addToSolutionFile)(host, projectConfiguration.root, dotnetClient, normalizedOptions.solutionFile);
        }
        if (options['testTemplate'] !== 'none') {
            yield (0, generate_test_project_1.GenerateTestProject)(host, normalizedOptions, dotnetClient);
        }
        if (normalizedOptions.projectTemplate === 'webapi' &&
            !normalizedOptions.skipSwaggerLib &&
            packageIsInstalled('@nx/js')) {
            tasks.push(yield (0, add_swagger_target_1.default)(host, {
                project: normalizedOptions.projectName,
                swaggerProject: `${normalizedOptions.nxProjectName}-swagger`,
                codegenProject: `${normalizedOptions.nxProjectName}-types`,
                useNxPluginOpenAPI: normalizedOptions.useNxPluginOpenAPI,
            }));
        }
        createGitIgnore(host, normalizedOptions.projectRoot);
        yield (0, devkit_1.formatFiles)(host);
        return () => tslib_1.__awaiter(this, void 0, void 0, function* () {
            for (const task of tasks) {
                yield task();
            }
        });
    });
}
exports.GenerateProject = GenerateProject;
function createGitIgnore(host, projectRoot) {
    const gitIgnorePath = (0, devkit_1.normalizePath)((0, devkit_1.joinPathFragments)(projectRoot, '.gitignore'));
    host.write(gitIgnorePath, `[Bb]in/\n[Oo]bj/`);
}
function addPrebuildMsbuildTask(host, options, xml) {
    const scriptPath = (0, devkit_1.normalizePath)((0, path_1.relative)(options.projectRoot, (0, utils_1.resolve)('@nx-dotnet/core/src/tasks/check-module-boundaries')));
    const fragment = new xmldoc_1.XmlDocument(`
    <Target Name="CheckNxModuleBoundaries" BeforeTargets="Build">
      <Exec Command="node ${scriptPath} -p ${options.projectName}"/>
    </Target>
  `);
    xml.children.push(fragment);
}
exports.addPrebuildMsbuildTask = addPrebuildMsbuildTask;
function packageIsInstalled(pkg) {
    try {
        require.resolve(pkg);
        return true;
    }
    catch (_a) {
        return false;
    }
}
//# sourceMappingURL=generate-project.js.map