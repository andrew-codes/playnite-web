"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const devkit_1 = require("@nx/devkit");
const path_1 = require("path");
const xmldoc_1 = require("xmldoc");
const dotnet_1 = require("@nx-dotnet/dotnet");
const utils_1 = require("@nx-dotnet/utils");
const models_1 = require("../../models");
const generator_1 = require("../init/generator");
function default_1(host, options, // The second option is provided at runtime by Nx for options passed in to the generator.
dotnetClient = new dotnet_1.DotNetClient((0, dotnet_1.dotnetFactory)())) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const installTask = yield (0, generator_1.initGenerator)(host, null, dotnetClient);
        const projectFiles = yield getProjectFilesInWorkspace(host);
        const existingProjectJsonDirectories = getDirectoriesWithProjectJson(host);
        for (const projectFile of projectFiles.newLibs) {
            if (!existingProjectJsonDirectories.some((x) => projectFile.startsWith(x + '/'))) {
                yield addNewDotnetProject(host, projectFile, false);
                devkit_1.logger.log('Found new library', projectFile);
            }
        }
        for (const projectFile of projectFiles.newApps) {
            if (!existingProjectJsonDirectories.some((x) => projectFile.startsWith(x + '/'))) {
                yield addNewDotnetProject(host, projectFile, true);
                devkit_1.logger.log('Found new application', projectFile);
            }
        }
        return () => tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield installTask();
            yield (0, devkit_1.formatFiles)(host);
        });
    });
}
exports.default = default_1;
function addNewDotnetProject(host, projectFile, app) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const rootNamespace = readRootNamespace(host, projectFile);
        const projectRoot = (0, path_1.dirname)(projectFile);
        const projectName = rootNamespace
            ? (0, devkit_1.names)(rootNamespace).fileName.replace(/\./g, '-')
            : (0, devkit_1.names)((0, path_1.basename)(projectRoot)).fileName;
        const configuration = {
            root: projectRoot,
            targets: {
                build: (0, models_1.GetBuildExecutorConfiguration)(projectRoot),
                lint: (0, models_1.GetLintExecutorConfiguration)(),
            },
            projectType: app ? 'application' : 'library',
        };
        const testProject = yield checkIfTestProject(host, projectFile);
        if (app && !testProject) {
            configuration.targets.serve = (0, models_1.GetServeExecutorConfig)();
        }
        if (testProject) {
            configuration.targets.test = (0, models_1.GetTestExecutorConfig)();
        }
        (0, devkit_1.addProjectConfiguration)(host, projectName, configuration);
    });
}
function getProjectFilesInWorkspace(host) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const { appsDir, libsDir } = (0, devkit_1.getWorkspaceLayout)(host);
        const newProjects = {
            newLibs: yield (0, utils_1.glob)((0, utils_1.projPattern)(libsDir)),
            newApps: [],
        };
        if (libsDir !== appsDir) {
            newProjects.newApps = yield (0, utils_1.glob)((0, utils_1.projPattern)(appsDir));
        }
        return newProjects;
    });
}
function readRootNamespace(host, path) {
    var _a;
    const xml = new xmldoc_1.XmlDocument((_a = host.read(path)) === null || _a === void 0 ? void 0 : _a.toString());
    return xml.valueWithPath('PropertyGroup.RootNamespace');
}
function checkIfTestProject(host, path) {
    var _a;
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const xml = new xmldoc_1.XmlDocument((_a = host.read(path)) === null || _a === void 0 ? void 0 : _a.toString());
        let isTestProject = false;
        yield (0, utils_1.iterateChildrenByPath)(xml, 'ItemGroup.PackageReference', (el) => {
            const pkg = el.attr['Include'];
            if (pkg === 'Microsoft.NET.Test.Sdk') {
                isTestProject = true;
            }
        });
        return isTestProject;
    });
}
function getDirectoriesWithProjectJson(host) {
    const nxProjects = (0, devkit_1.getProjects)(host);
    const collected = [];
    for (const proj of nxProjects.values()) {
        if (host.exists((0, devkit_1.joinPathFragments)(proj.root, 'project.json'))) {
            collected.push(proj.root);
        }
    }
    return collected;
}
//# sourceMappingURL=generator.js.map