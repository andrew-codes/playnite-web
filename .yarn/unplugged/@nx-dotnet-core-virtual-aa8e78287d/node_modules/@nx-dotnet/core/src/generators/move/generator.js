"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const devkit_1 = require("@nx/devkit");
const path_1 = require("path");
function normalizeOptions(tree, options) {
    const { appsDir, libsDir } = (0, devkit_1.getWorkspaceLayout)(tree);
    const currentRoot = (0, devkit_1.readProjectConfiguration)(tree, options.projectName).root;
    let destinationRoot = options.destination;
    if (!options.relativeToRoot) {
        if (currentRoot.startsWith(appsDir)) {
            destinationRoot = (0, devkit_1.joinPathFragments)(appsDir, options.destination.replace(new RegExp(`^${appsDir}`), ''));
        }
        else if (currentRoot.startsWith(libsDir)) {
            destinationRoot = (0, devkit_1.joinPathFragments)(libsDir, options.destination.replace(new RegExp(`^${libsDir}`), ''));
        }
    }
    return {
        currentRoot,
        destinationRoot,
        currentProject: options.projectName,
        destinationProject: (0, devkit_1.names)(options.destination).fileName.replace(/[\\|/]/g, '-'),
    };
}
function default_1(tree, options) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const normalizedOptions = normalizeOptions(tree, options);
        const config = (0, devkit_1.readProjectConfiguration)(tree, normalizedOptions.currentProject);
        config.root = normalizedOptions.destinationRoot;
        config.name = normalizedOptions.destinationProject;
        (0, devkit_1.removeProjectConfiguration)(tree, normalizedOptions.currentProject);
        renameDirectory(tree, normalizedOptions.currentRoot, normalizedOptions.destinationRoot);
        (0, devkit_1.addProjectConfiguration)(tree, options.projectName, transformConfiguration(tree, config, normalizedOptions));
        updateXmlReferences(tree, normalizedOptions);
        yield (0, devkit_1.formatFiles)(tree);
    });
}
exports.default = default_1;
function transformConfiguration(tree, config, options) {
    const copy = updateReferencesInObject(config, options);
    updateSchemaPath(tree, copy, config.root);
    return copy;
}
function updateSchemaPath(tree, config, projectRoot) {
    var _a;
    const relativeToRoot = (0, devkit_1.offsetFromRoot)(projectRoot);
    config.$schema = (_a = config.$schema) === null || _a === void 0 ? void 0 : _a.replace(/^.*\/node_modules/, (0, devkit_1.joinPathFragments)(relativeToRoot, 'node_modules'));
}
function updateReferencesInObject(object, options) {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const newValue = Array.isArray(object)
        ? []
        : {};
    for (const key in object) {
        if (typeof object[key] === 'string') {
            newValue[key] = object[key].replace(options.currentRoot, options.destinationRoot);
        }
        else if (typeof object[key] === 'object') {
            newValue[key] = updateReferencesInObject(object[key], options);
        }
        else {
            newValue[key] = object[key];
        }
    }
    return newValue;
}
function updateXmlReferences(tree, options) {
    (0, devkit_1.visitNotIgnoredFiles)(tree, '.', (path) => {
        const extension = (0, path_1.extname)(path);
        const directory = (0, path_1.dirname)(path);
        if (['.csproj', '.vbproj', '.fsproj', '.sln'].includes(extension)) {
            const contents = tree.read(path);
            if (!contents) {
                return;
            }
            const pathToUpdate = (0, devkit_1.normalizePath)((0, path_1.relative)(directory, options.currentRoot));
            const pathToUpdateWithWindowsSeparators = (0, devkit_1.normalizePath)((0, path_1.relative)(directory, options.currentRoot)).replaceAll('/', '\\');
            const newPath = (0, devkit_1.normalizePath)((0, path_1.relative)(directory, options.destinationRoot));
            console.log({ pathToUpdate, newPath });
            tree.write(path, contents
                .toString()
                .replaceAll(pathToUpdate, newPath)
                .replaceAll(pathToUpdateWithWindowsSeparators, newPath));
        }
    });
}
function renameDirectory(tree, from, to) {
    const children = tree.children(from);
    for (const child of children) {
        const childFrom = (0, devkit_1.joinPathFragments)(from, child);
        const childTo = (0, devkit_1.joinPathFragments)(to, child);
        if (tree.isFile(childFrom)) {
            tree.rename(childFrom, childTo);
        }
        else {
            renameDirectory(tree, childFrom, childTo);
        }
    }
    if (!to.startsWith(from)) {
        tree.delete(from);
    }
}
//# sourceMappingURL=generator.js.map