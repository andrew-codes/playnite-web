"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.updateFileMap = exports.createFileMap = exports.createProjectFileMapUsingProjectGraph = void 0;
const find_project_for_path_1 = require("./utils/find-project-for-path");
const client_1 = require("../daemon/client/client");
const project_graph_1 = require("./project-graph");
const workspace_context_1 = require("../utils/workspace-context");
const workspace_root_1 = require("../utils/workspace-root");
async function createProjectFileMapUsingProjectGraph(graph) {
    const configs = (0, project_graph_1.readProjectsConfigurationFromProjectGraph)(graph);
    let files;
    if (client_1.daemonClient.enabled()) {
        files = await client_1.daemonClient.getAllFileData();
    }
    else {
        files = (0, workspace_context_1.getAllFileDataInContext)(workspace_root_1.workspaceRoot);
    }
    return createFileMap(configs, files).fileMap.projectFileMap;
}
exports.createProjectFileMapUsingProjectGraph = createProjectFileMapUsingProjectGraph;
function createFileMap(projectsConfigurations, allWorkspaceFiles) {
    const projectFileMap = {};
    const projectRootMappings = (0, find_project_for_path_1.createProjectRootMappingsFromProjectConfigurations)(projectsConfigurations.projects);
    const nonProjectFiles = [];
    for (const projectName of Object.keys(projectsConfigurations.projects)) {
        projectFileMap[projectName] ??= [];
    }
    for (const f of allWorkspaceFiles) {
        const projectFileMapKey = (0, find_project_for_path_1.findProjectForPath)(f.file, projectRootMappings);
        if (projectFileMapKey) {
            const matchingProjectFiles = projectFileMap[projectFileMapKey];
            if (matchingProjectFiles) {
                matchingProjectFiles.push(f);
            }
        }
        else {
            nonProjectFiles.push(f);
        }
    }
    return {
        allWorkspaceFiles,
        fileMap: {
            projectFileMap,
            nonProjectFiles,
        },
    };
}
exports.createFileMap = createFileMap;
function updateFileMap(projectsConfigurations, { projectFileMap, nonProjectFiles }, allWorkspaceFiles, updatedFiles, deletedFiles) {
    const projectRootMappings = (0, find_project_for_path_1.createProjectRootMappingsFromProjectConfigurations)(projectsConfigurations);
    let nonProjectFilesMap = new Map(nonProjectFiles.map((f) => [f.file, f]));
    for (const f of updatedFiles.keys()) {
        const project = (0, find_project_for_path_1.findProjectForPath)(f, projectRootMappings);
        if (project) {
            const matchingProjectFiles = projectFileMap[project] ?? [];
            if (matchingProjectFiles) {
                const fileData = matchingProjectFiles.find((t) => t.file === f);
                if (fileData) {
                    fileData.hash = updatedFiles.get(f);
                }
                else {
                    matchingProjectFiles.push({
                        file: f,
                        hash: updatedFiles.get(f),
                    });
                }
            }
        }
        else {
            const hash = updatedFiles.get(f);
            const entry = nonProjectFilesMap.get(f) ?? { file: f, hash };
            entry.hash = hash;
            nonProjectFilesMap.set(f, entry);
        }
        const fileData = allWorkspaceFiles.find((t) => t.file === f);
        if (fileData) {
            fileData.hash = updatedFiles.get(f);
        }
        else {
            allWorkspaceFiles.push({
                file: f,
                hash: updatedFiles.get(f),
            });
        }
    }
    for (const f of deletedFiles) {
        const matchingProjectFiles = projectFileMap[(0, find_project_for_path_1.findProjectForPath)(f, projectRootMappings)] ?? [];
        if (matchingProjectFiles) {
            const index = matchingProjectFiles.findIndex((t) => t.file === f);
            if (index > -1) {
                matchingProjectFiles.splice(index, 1);
            }
        }
        if (nonProjectFilesMap.has(f)) {
            nonProjectFilesMap.delete(f);
        }
        const index = allWorkspaceFiles.findIndex((t) => t.file === f);
        if (index > -1) {
            allWorkspaceFiles.splice(index, 1);
        }
    }
    return {
        fileMap: {
            projectFileMap,
            nonProjectFiles: Array.from(nonProjectFilesMap.values()),
        },
        allWorkspaceFiles,
    };
}
exports.updateFileMap = updateFileMap;
