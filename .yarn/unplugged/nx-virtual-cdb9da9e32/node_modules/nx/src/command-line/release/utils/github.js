"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.formatReferences = exports.getGithubReleaseByTag = exports.resolveGithubToken = exports.createOrUpdateGithubRelease = exports.getGitHubRepoSlug = void 0;
const chalk = require("chalk");
const node_child_process_1 = require("node:child_process");
const node_fs_1 = require("node:fs");
const node_os_1 = require("node:os");
const path_1 = require("../../../utils/path");
// axios types and values don't seem to match
const _axios = require("axios");
const axios = _axios;
function getGitHubRepoSlug(remoteName = 'origin') {
    try {
        const remoteUrl = (0, node_child_process_1.execSync)(`git remote get-url ${remoteName}`, {
            encoding: 'utf8',
            stdio: 'pipe',
        }).trim();
        // Extract the 'user/repo' part from the URL
        const regex = /github\.com[/:]([\w-]+\/[\w-]+)/;
        const match = remoteUrl.match(regex);
        if (match && match[1]) {
            return match[1];
        }
        else {
            throw new Error(`Could not extract "user/repo" data from the resolved remote URL: ${remoteUrl}`);
        }
    }
    catch (error) {
        return null;
    }
}
exports.getGitHubRepoSlug = getGitHubRepoSlug;
async function createOrUpdateGithubRelease(githubRequestConfig, release, existingGithubReleaseForVersion) {
    const result = await syncGithubRelease(githubRequestConfig, release, existingGithubReleaseForVersion);
    /**
     * If something went wrong POSTing to Github we can still pre-populate the web form on github.com
     * to allow the user to manually complete the release.
     */
    if (result.status === 'manual') {
        if (result.error) {
            console.error(result.error);
            process.exitCode = 1;
        }
        const open = require('open');
        await open(result.url)
            .then(() => {
            console.info(`Follow up in the browser to manually create the release.`);
        })
            .catch(() => {
            console.info(`Open this link to manually create a release: \n` +
                chalk.underline(chalk.cyan(result.url)) +
                '\n');
        });
    }
}
exports.createOrUpdateGithubRelease = createOrUpdateGithubRelease;
async function syncGithubRelease(githubRequestConfig, release, existingGithubReleaseForVersion) {
    const ghRelease = {
        tag_name: release.version,
        name: release.version,
        body: release.body,
        prerelease: release.prerelease,
    };
    try {
        const newGhRelease = await (existingGithubReleaseForVersion
            ? updateGithubRelease(githubRequestConfig, existingGithubReleaseForVersion.id, ghRelease)
            : createGithubRelease(githubRequestConfig, {
                ...ghRelease,
                target_commitish: release.commit,
            }));
        return {
            status: existingGithubReleaseForVersion ? 'updated' : 'created',
            id: newGhRelease.id,
            url: newGhRelease.html_url,
        };
    }
    catch (error) {
        return {
            status: 'manual',
            error,
            url: githubNewReleaseURL(githubRequestConfig, release),
        };
    }
}
async function resolveGithubToken() {
    // Try and resolve from the environment
    const tokenFromEnv = process.env.GITHUB_TOKEN || process.env.GH_TOKEN;
    if (tokenFromEnv) {
        return tokenFromEnv;
    }
    // Try and resolve from gh CLI installation
    const ghCLIPath = (0, path_1.joinPathFragments)(process.env.XDG_CONFIG_HOME || (0, path_1.joinPathFragments)((0, node_os_1.homedir)(), '.config'), 'gh', 'hosts.yml');
    if ((0, node_fs_1.existsSync)(ghCLIPath)) {
        const yamlContents = await node_fs_1.promises.readFile(ghCLIPath, 'utf8');
        const { load } = require('@zkochan/js-yaml');
        const ghCLIConfig = load(yamlContents);
        return ghCLIConfig['github.com'].oauth_token;
    }
    return null;
}
exports.resolveGithubToken = resolveGithubToken;
async function getGithubReleaseByTag(config, tag) {
    return await makeGithubRequest(config, `/repos/${config.repo}/releases/tags/${tag}`, {});
}
exports.getGithubReleaseByTag = getGithubReleaseByTag;
async function makeGithubRequest(config, url, opts = {}) {
    return (await axios(url, {
        ...opts,
        baseURL: 'https://api.github.com',
        headers: {
            ...opts.headers,
            Authorization: config.token ? `Bearer ${config.token}` : undefined,
        },
    })).data;
}
async function createGithubRelease(config, body) {
    return await makeGithubRequest(config, `/repos/${config.repo}/releases`, {
        method: 'POST',
        data: body,
    });
}
async function updateGithubRelease(config, id, body) {
    return await makeGithubRequest(config, `/repos/${config.repo}/releases/${id}`, {
        method: 'PATCH',
        data: body,
    });
}
function githubNewReleaseURL(config, release) {
    return `https://github.com/${config.repo}/releases/new?tag=v${release.version}&title=v${release.version}&body=${encodeURIComponent(release.body)}`;
}
const providerToRefSpec = {
    github: { 'pull-request': 'pull', hash: 'commit', issue: 'issues' },
};
function formatReference(ref, repoSlug) {
    const refSpec = providerToRefSpec['github'];
    return `[${ref.value}](https://github.com/${repoSlug}/${refSpec[ref.type]}/${ref.value.replace(/^#/, '')})`;
}
function formatReferences(references, repoSlug) {
    const pr = references.filter((ref) => ref.type === 'pull-request');
    const issue = references.filter((ref) => ref.type === 'issue');
    if (pr.length > 0 || issue.length > 0) {
        return (' (' +
            [...pr, ...issue]
                .map((ref) => formatReference(ref, repoSlug))
                .join(', ') +
            ')');
    }
    if (references.length > 0) {
        return ' (' + formatReference(references[0], repoSlug) + ')';
    }
    return '';
}
exports.formatReferences = formatReferences;
