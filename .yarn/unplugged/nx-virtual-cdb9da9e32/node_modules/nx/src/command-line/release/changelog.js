"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.changelogHandler = void 0;
const chalk = require("chalk");
const node_fs_1 = require("node:fs");
const semver_1 = require("semver");
const tmp_1 = require("tmp");
const nx_json_1 = require("../../config/nx-json");
const tree_1 = require("../../generators/tree");
const register_1 = require("../../plugins/js/utils/register");
const project_graph_1 = require("../../project-graph/project-graph");
const utils_1 = require("../../tasks-runner/utils");
const logger_1 = require("../../utils/logger");
const output_1 = require("../../utils/output");
const path_1 = require("../../utils/path");
const typescript_1 = require("../../utils/typescript");
const workspace_root_1 = require("../../utils/workspace-root");
const config_1 = require("./config/config");
const filter_release_groups_1 = require("./config/filter-release-groups");
const git_1 = require("./utils/git");
const github_1 = require("./utils/github");
const launch_editor_1 = require("./utils/launch-editor");
const markdown_1 = require("./utils/markdown");
const print_changes_1 = require("./utils/print-changes");
const params_1 = require("../../utils/params");
class ReleaseVersion {
    constructor({ version, // short form version string with no prefixes or patterns, e.g. 1.0.0
    releaseTagPattern, // full pattern to interpolate, e.g. "v{version}" or "{projectName}@{version}"
    projectName, // optional project name to interpolate into the releaseTagPattern
     }) {
        this.rawVersion = version;
        this.gitTag = (0, utils_1.interpolate)(releaseTagPattern, {
            version,
            projectName,
        });
        this.isPrerelease = isPrerelease(version);
    }
}
async function changelogHandler(args) {
    return (0, params_1.handleErrors)(args.verbose, async () => {
        // Right now, the given version must be valid semver in order to proceed
        if (!(0, semver_1.valid)(args.version)) {
            output_1.output.error({
                title: `The given version "${args.version}" is not a valid semver version. Please provide your version in the format "1.0.0", "1.0.0-beta.1" etc`,
            });
            process.exit(1);
        }
        const projectGraph = await (0, project_graph_1.createProjectGraphAsync)({ exitOnError: true });
        const nxJson = (0, nx_json_1.readNxJson)();
        const commitHash = await (0, git_1.getCommitHash)(args.to);
        if (args.verbose) {
            process.env.NX_VERBOSE_LOGGING = 'true';
        }
        // Apply default configuration to any optional user configuration
        const { error: configError, nxReleaseConfig } = await (0, config_1.createNxReleaseConfig)(projectGraph, nxJson.release);
        if (configError) {
            return await (0, config_1.handleNxReleaseConfigError)(configError);
        }
        const { error: filterError, releaseGroups, releaseGroupToFilteredProjects, } = (0, filter_release_groups_1.filterReleaseGroups)(projectGraph, nxReleaseConfig, args.projects, args.groups);
        if (filterError) {
            output_1.output.error(filterError);
            process.exit(1);
        }
        const releaseVersion = new ReleaseVersion({
            version: args.version,
            releaseTagPattern: nxReleaseConfig.releaseTagPattern,
        });
        const from = args.from ||
            (await (0, git_1.getLatestGitTagForPattern)(nxReleaseConfig.releaseTagPattern))?.tag;
        if (!from) {
            output_1.output.error({
                title: `Unable to determine the previous git tag, please provide an explicit git reference using --from`,
            });
            process.exit(1);
        }
        const rawCommits = await (0, git_1.getGitDiff)(from, args.to);
        // Parse as conventional commits
        const commits = (0, git_1.parseCommits)(rawCommits).filter((c) => {
            const type = c.type;
            // Always ignore non user-facing commits for now
            // TODO: allow this filter to be configurable via config in a future release
            if (type === 'feat' || type === 'fix' || type === 'perf') {
                return true;
            }
            return false;
        });
        const tree = new tree_1.FsTree(workspace_root_1.workspaceRoot, args.verbose);
        await generateChangelogForWorkspace(tree, releaseVersion, !!args.dryRun, 
        // Only trigger interactive mode for the workspace changelog if the user explicitly requested it via "all" or "workspace"
        args.interactive === 'all' || args.interactive === 'workspace', commitHash, commits, nxReleaseConfig.changelog.workspaceChangelog, args.gitRemote);
        if (args.projects?.length) {
            /**
             * Run changelog generation for all remaining release groups and filtered projects within them
             */
            for (const releaseGroup of releaseGroups) {
                const projectNodes = Array.from(releaseGroupToFilteredProjects.get(releaseGroup)).map((name) => projectGraph.nodes[name]);
                await generateChangelogForProjects(tree, args.version, !!args.dryRun, 
                // Only trigger interactive mode for the workspace changelog if the user explicitly requested it via "all" or "projects"
                args.interactive === 'all' || args.interactive === 'projects', commitHash, commits, releaseGroup.changelog, releaseGroup.releaseTagPattern, projectNodes, args.gitRemote);
            }
            return process.exit(0);
        }
        /**
         * Run changelog generation for all remaining release groups
         */
        for (const releaseGroup of releaseGroups) {
            const projectNodes = releaseGroup.projects.map((name) => projectGraph.nodes[name]);
            await generateChangelogForProjects(tree, args.version, !!args.dryRun, 
            // Only trigger interactive mode for the workspace changelog if the user explicitly requested it via "all" or "projects"
            args.interactive === 'all' || args.interactive === 'projects', commitHash, commits, releaseGroup.changelog, releaseGroup.releaseTagPattern, projectNodes, args.gitRemote);
        }
        if (args.dryRun) {
            logger_1.logger.warn(`\nNOTE: The "dryRun" flag means no changelogs were actually created.`);
        }
        process.exit(0);
    });
}
exports.changelogHandler = changelogHandler;
function isPrerelease(version) {
    // prerelease returns an array of matching prerelease "components", or null if the version is not a prerelease
    return (0, semver_1.prerelease)(version) !== null;
}
function resolveChangelogRenderer(changelogRendererPath) {
    // Try and load the provided (or default) changelog renderer
    let changelogRenderer;
    let cleanupTranspiler = () => { };
    try {
        const rootTsconfigPath = (0, typescript_1.getRootTsConfigPath)();
        if (rootTsconfigPath) {
            cleanupTranspiler = (0, register_1.registerTsProject)(rootTsconfigPath);
        }
        const r = require(changelogRendererPath);
        changelogRenderer = r.default || r;
    }
    catch {
    }
    finally {
        cleanupTranspiler();
    }
    return changelogRenderer;
}
async function generateChangelogForWorkspace(tree, releaseVersion, dryRun, interactive, commit, commits, config, gitRemote) {
    // The entire feature is disabled at the workspace level, exit early
    if (config === false) {
        return;
    }
    const changelogRenderer = resolveChangelogRenderer(config.renderer);
    let interpolatedTreePath = config.file || '';
    if (interpolatedTreePath) {
        interpolatedTreePath = (0, utils_1.interpolate)(interpolatedTreePath, {
            projectName: '',
            projectRoot: '',
            workspaceRoot: '', // within the tree, workspaceRoot is the root
        });
    }
    // We are either creating/previewing a changelog file, a Github release, or both
    let logTitle = dryRun ? 'Previewing a' : 'Generating a';
    switch (true) {
        case interpolatedTreePath && config.createRelease === 'github':
            logTitle += ` Github release and an entry in ${interpolatedTreePath} for ${chalk.white(releaseVersion.gitTag)}`;
            break;
        case !!interpolatedTreePath:
            logTitle += `n entry in ${interpolatedTreePath} for ${chalk.white(releaseVersion.gitTag)}`;
            break;
        case config.createRelease === 'github':
            logTitle += ` Github release for ${chalk.white(releaseVersion.gitTag)}`;
    }
    output_1.output.log({
        title: logTitle,
    });
    const githubRepoSlug = config.createRelease === 'github'
        ? (0, github_1.getGitHubRepoSlug)(gitRemote)
        : undefined;
    let contents = await changelogRenderer({
        commits,
        releaseVersion: releaseVersion.rawVersion,
        project: null,
        repoSlug: githubRepoSlug,
        entryWhenNoChanges: config.entryWhenNoChanges,
        changelogRenderOptions: config.renderOptions,
    });
    /**
     * If interactive mode, make the changelog contents available for the user to modify in their editor of choice,
     * in a similar style to git interactive rebases/merges.
     */
    if (interactive) {
        const tmpDir = (0, tmp_1.dirSync)().name;
        const changelogPath = (0, path_1.joinPathFragments)(tmpDir, 
        // Include the tree path in the name so that it is easier to identify which changelog file is being edited
        `PREVIEW__${interpolatedTreePath.replace(/\//g, '_')}`);
        (0, node_fs_1.writeFileSync)(changelogPath, contents);
        await (0, launch_editor_1.launchEditor)(changelogPath);
        contents = (0, node_fs_1.readFileSync)(changelogPath, 'utf-8');
    }
    /**
     * The exact logic we use for printing the summary/diff to the user is dependent upon whether they are creating
     * a changelog file, a Github release, or both.
     */
    let printSummary = () => { };
    const noDiffInChangelogMessage = chalk.yellow(`NOTE: There was no diff detected for the changelog entry. Maybe you intended to pass alternative git references via --from and --to?`);
    if (interpolatedTreePath) {
        let rootChangelogContents = tree.read(interpolatedTreePath)?.toString() ?? '';
        if (rootChangelogContents) {
            // NOTE: right now existing releases are always expected to be in markdown format, but in the future we could potentially support others via a custom parser option
            const changelogReleases = (0, markdown_1.parseChangelogMarkdown)(rootChangelogContents).releases;
            const existingVersionToUpdate = changelogReleases.find((r) => r.version === releaseVersion.rawVersion);
            if (existingVersionToUpdate) {
                rootChangelogContents = rootChangelogContents.replace(`## ${releaseVersion.rawVersion}\n\n\n${existingVersionToUpdate.body}`, contents);
            }
            else {
                // No existing version, simply prepend the new release to the top of the file
                rootChangelogContents = `${contents}\n\n${rootChangelogContents}`;
            }
        }
        else {
            // No existing changelog contents, simply create a new one using the generated contents
            rootChangelogContents = contents;
        }
        tree.write(interpolatedTreePath, rootChangelogContents);
        printSummary = () => (0, print_changes_1.printChanges)(tree, !!dryRun, 3, false, noDiffInChangelogMessage);
    }
    if (config.createRelease === 'github') {
        if (!githubRepoSlug) {
            output_1.output.error({
                title: `Unable to create a Github release because the Github repo slug could not be determined.`,
                bodyLines: [
                    `Please ensure you have a valid Github remote configured. You can run \`git remote -v\` to list your current remotes.`,
                ],
            });
            process.exit(1);
        }
        const token = await (0, github_1.resolveGithubToken)();
        const githubRequestConfig = {
            repo: githubRepoSlug,
            token,
        };
        let existingGithubReleaseForVersion;
        try {
            existingGithubReleaseForVersion = await (0, github_1.getGithubReleaseByTag)(githubRequestConfig, releaseVersion.gitTag);
        }
        catch (err) {
            if (err.response?.status === 401) {
                output_1.output.error({
                    title: `Unable to resolve data via the Github API. You can use any of the following options to resolve this:`,
                    bodyLines: [
                        '- Set the `GITHUB_TOKEN` or `GH_TOKEN` environment variable to a valid Github token with `repo` scope',
                        '- Have an active session via the official gh CLI tool (https://cli.github.com) in your current terminal',
                    ],
                });
                process.exit(1);
            }
            if (err.response?.status === 404) {
                // No existing release found, this is fine
            }
            else {
                // Rethrow unknown errors for now
                throw err;
            }
        }
        let existingPrintSummaryFn = printSummary;
        printSummary = () => {
            const logTitle = `https://github.com/${githubRepoSlug}/releases/tag/${releaseVersion.gitTag}`;
            if (existingGithubReleaseForVersion) {
                console.error(`${chalk.white('UPDATE')} ${logTitle}${dryRun ? chalk.keyword('orange')(' [dry-run]') : ''}`);
            }
            else {
                console.error(`${chalk.green('CREATE')} ${logTitle}${dryRun ? chalk.keyword('orange')(' [dry-run]') : ''}`);
            }
            // Only print the diff here if we are not already going to be printing changes from the Tree
            if (!interpolatedTreePath) {
                console.log('');
                (0, print_changes_1.printDiff)(existingGithubReleaseForVersion
                    ? existingGithubReleaseForVersion.body
                    : '', contents, 3, noDiffInChangelogMessage);
            }
            existingPrintSummaryFn();
        };
        if (!dryRun) {
            await (0, github_1.createOrUpdateGithubRelease)(githubRequestConfig, {
                version: releaseVersion.gitTag,
                prerelease: releaseVersion.isPrerelease,
                body: contents,
                commit,
            }, existingGithubReleaseForVersion);
        }
    }
    printSummary();
}
async function generateChangelogForProjects(tree, rawVersion, dryRun, interactive, commit, commits, config, releaseTagPattern, projects, gitRemote) {
    // The entire feature is disabled at the project level, exit early
    if (config === false) {
        return;
    }
    const changelogRenderer = resolveChangelogRenderer(config.renderer);
    for (const project of projects) {
        let interpolatedTreePath = config.file || '';
        if (interpolatedTreePath) {
            interpolatedTreePath = (0, utils_1.interpolate)(interpolatedTreePath, {
                projectName: project.name,
                projectRoot: project.data.root,
                workspaceRoot: '', // within the tree, workspaceRoot is the root
            });
        }
        const releaseVersion = new ReleaseVersion({
            version: rawVersion,
            releaseTagPattern,
            projectName: project.name,
        });
        // We are either creating/previewing a changelog file, a Github release, or both
        let logTitle = dryRun ? 'Previewing a' : 'Generating a';
        switch (true) {
            case interpolatedTreePath && config.createRelease === 'github':
                logTitle += ` Github release and an entry in ${interpolatedTreePath} for ${chalk.white(releaseVersion.gitTag)}`;
                break;
            case !!interpolatedTreePath:
                logTitle += `n entry in ${interpolatedTreePath} for ${chalk.white(releaseVersion.gitTag)}`;
                break;
            case config.createRelease === 'github':
                logTitle += ` Github release for ${chalk.white(releaseVersion.gitTag)}`;
        }
        output_1.output.log({
            title: logTitle,
        });
        const githubRepoSlug = config.createRelease === 'github'
            ? (0, github_1.getGitHubRepoSlug)(gitRemote)
            : undefined;
        let contents = await changelogRenderer({
            commits,
            releaseVersion: releaseVersion.rawVersion,
            project: null,
            repoSlug: githubRepoSlug,
            entryWhenNoChanges: typeof config.entryWhenNoChanges === 'string'
                ? (0, utils_1.interpolate)(config.entryWhenNoChanges, {
                    projectName: project.name,
                    projectRoot: project.data.root,
                    workspaceRoot: '', // within the tree, workspaceRoot is the root
                })
                : false,
            changelogRenderOptions: config.renderOptions,
        });
        /**
         * If interactive mode, make the changelog contents available for the user to modify in their editor of choice,
         * in a similar style to git interactive rebases/merges.
         */
        if (interactive) {
            const tmpDir = (0, tmp_1.dirSync)().name;
            const changelogPath = (0, path_1.joinPathFragments)(tmpDir, 
            // Include the tree path in the name so that it is easier to identify which changelog file is being edited
            `PREVIEW__${interpolatedTreePath.replace(/\//g, '_')}`);
            (0, node_fs_1.writeFileSync)(changelogPath, contents);
            await (0, launch_editor_1.launchEditor)(changelogPath);
            contents = (0, node_fs_1.readFileSync)(changelogPath, 'utf-8');
        }
        /**
         * The exact logic we use for printing the summary/diff to the user is dependent upon whether they are creating
         * a changelog file, a Github release, or both.
         */
        let printSummary = () => { };
        const noDiffInChangelogMessage = chalk.yellow(`NOTE: There was no diff detected for the changelog entry. Maybe you intended to pass alternative git references via --from and --to?`);
        if (interpolatedTreePath) {
            let changelogContents = tree.read(interpolatedTreePath)?.toString() ?? '';
            if (changelogContents) {
                // NOTE: right now existing releases are always expected to be in markdown format, but in the future we could potentially support others via a custom parser option
                const changelogReleases = (0, markdown_1.parseChangelogMarkdown)(changelogContents).releases;
                const existingVersionToUpdate = changelogReleases.find((r) => r.version === releaseVersion.rawVersion);
                if (existingVersionToUpdate) {
                    changelogContents = changelogContents.replace(`## ${releaseVersion.rawVersion}\n\n\n${existingVersionToUpdate.body}`, contents);
                }
                else {
                    // No existing version, simply prepend the new release to the top of the file
                    changelogContents = `${contents}\n\n${changelogContents}`;
                }
            }
            else {
                // No existing changelog contents, simply create a new one using the generated contents
                changelogContents = contents;
            }
            tree.write(interpolatedTreePath, changelogContents);
            printSummary = () => (0, print_changes_1.printChanges)(tree, !!dryRun, 3, false, noDiffInChangelogMessage, 
            // Only print the change for the current changelog file at this point
            (f) => f.path === interpolatedTreePath);
        }
        if (config.createRelease === 'github') {
            if (!githubRepoSlug) {
                output_1.output.error({
                    title: `Unable to create a Github release because the Github repo slug could not be determined.`,
                    bodyLines: [
                        `Please ensure you have a valid Github remote configured. You can run \`git remote -v\` to list your current remotes.`,
                    ],
                });
                process.exit(1);
            }
            const token = await (0, github_1.resolveGithubToken)();
            const githubRequestConfig = {
                repo: githubRepoSlug,
                token,
            };
            let existingGithubReleaseForVersion;
            try {
                existingGithubReleaseForVersion = await (0, github_1.getGithubReleaseByTag)(githubRequestConfig, releaseVersion.gitTag);
            }
            catch (err) {
                if (err.response?.status === 401) {
                    output_1.output.error({
                        title: `Unable to resolve data via the Github API. You can use any of the following options to resolve this:`,
                        bodyLines: [
                            '- Set the `GITHUB_TOKEN` or `GH_TOKEN` environment variable to a valid Github token with `repo` scope',
                            '- Have an active session via the official gh CLI tool (https://cli.github.com) in your current terminal',
                        ],
                    });
                    process.exit(1);
                }
                if (err.response?.status === 404) {
                    // No existing release found, this is fine
                }
                else {
                    // Rethrow unknown errors for now
                    throw err;
                }
            }
            let existingPrintSummaryFn = printSummary;
            printSummary = () => {
                const logTitle = `https://github.com/${githubRepoSlug}/releases/tag/${releaseVersion.gitTag}`;
                if (existingGithubReleaseForVersion) {
                    console.error(`${chalk.white('UPDATE')} ${logTitle}${dryRun ? chalk.keyword('orange')(' [dry-run]') : ''}`);
                }
                else {
                    console.error(`${chalk.green('CREATE')} ${logTitle}${dryRun ? chalk.keyword('orange')(' [dry-run]') : ''}`);
                }
                // Only print the diff here if we are not already going to be printing changes from the Tree
                if (!interpolatedTreePath) {
                    console.log('');
                    (0, print_changes_1.printDiff)(existingGithubReleaseForVersion
                        ? existingGithubReleaseForVersion.body
                        : '', contents, 3, noDiffInChangelogMessage);
                }
                existingPrintSummaryFn();
            };
            if (!dryRun) {
                await (0, github_1.createOrUpdateGithubRelease)(githubRequestConfig, {
                    version: releaseVersion.gitTag,
                    prerelease: releaseVersion.isPrerelease,
                    body: contents,
                    commit,
                }, existingGithubReleaseForVersion);
            }
        }
        printSummary();
    }
}
